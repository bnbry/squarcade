<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Xon Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            font-family: 'Orbitron', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1 {
            font-size: 3em;
            font-weight: 900;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00f5ff, #ff00ff, #ffff00, #00ff00);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        @keyframes rainbow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        #gameCanvas {
            border: 3px solid #00f5ff;
            border-radius: 10px;
            background-color: #000;
            box-shadow: 
                0 0 20px rgba(0, 245, 255, 0.6),
                0 0 40px rgba(0, 245, 255, 0.4),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            animation: borderGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes borderGlow {
            from { 
                border-color: #00f5ff;
                box-shadow: 
                    0 0 20px rgba(0, 245, 255, 0.6),
                    0 0 40px rgba(0, 245, 255, 0.4),
                    inset 0 0 20px rgba(0, 0, 0, 0.5);
            }
            to { 
                border-color: #ff00ff;
                box-shadow: 
                    0 0 30px rgba(255, 0, 255, 0.8),
                    0 0 60px rgba(255, 0, 255, 0.6),
                    inset 0 0 20px rgba(0, 0, 0, 0.5);
            }
        }
        
        #gameInfo {
            margin-top: 20px;
            display: flex;
            gap: 30px;
            font-size: 18px;
            font-weight: 700;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid rgba(0, 245, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #gameInfo > div {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        #gameInfo span {
            color: #00ff00;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }
        
        #controls {
            margin-top: 25px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }
        
        #controls p {
            margin: 8px 0;
            color: #cccccc;
            font-size: 14px;
        }
        
        .key {
            display: inline-block;
            background: linear-gradient(145deg, #333, #555);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            margin: 0 2px;
        }

        /* Victory Screen Styles */
        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .victory-content {
            text-align: center;
            background: linear-gradient(145deg, rgba(0, 20, 40, 0.9), rgba(20, 0, 40, 0.9));
            border: 3px solid #00f5ff;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 
                0 0 30px rgba(0, 245, 255, 0.8),
                0 0 60px rgba(0, 245, 255, 0.4),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            animation: victoryPulse 2s ease-in-out infinite alternate;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 
                    0 0 30px rgba(0, 245, 255, 0.8),
                    0 0 60px rgba(0, 245, 255, 0.4),
                    inset 0 0 30px rgba(0, 0, 0, 0.3);
            }
            to { 
                box-shadow: 
                    0 0 50px rgba(255, 0, 255, 1),
                    0 0 100px rgba(255, 0, 255, 0.6),
                    inset 0 0 30px rgba(0, 0, 0, 0.3);
            }
        }

        .victory-title {
            font-size: 3.5em;
            font-weight: 900;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ffff00, #ff00ff, #00ff00, #00f5ff);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow 2s ease-in-out infinite, bounce 1s ease-in-out infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0px); }
            to { transform: translateY(-10px); }
        }

        .victory-stats {
            margin: 30px 0;
            display: flex;
            gap: 40px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .victory-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .victory-stat-label {
            color: #cccccc;
            font-size: 1.1em;
            text-transform: uppercase;
        }

        .victory-stat-value {
            color: #00ff00;
            font-size: 2em;
            font-weight: 900;
            text-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        .next-level-btn {
            background: linear-gradient(145deg, #00ff00, #00cc00);
            border: none;
            color: #000;
            padding: 15px 40px;
            font-size: 1.4em;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 
                0 5px 15px rgba(0, 255, 0, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            animation: buttonGlow 2s ease-in-out infinite alternate;
        }

        @keyframes buttonGlow {
            from { box-shadow: 0 5px 15px rgba(0, 255, 0, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.2); }
            to { box-shadow: 0 10px 30px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.4); }
        }

        .next-level-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 10px 25px rgba(0, 255, 0, 0.6),
                inset 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .next-level-btn:active {
            transform: translateY(-1px) scale(1.02);
        }

        .celebration-text {
            color: #ffff00;
            font-size: 1.3em;
            margin: 20px 0;
            animation: sparkle 1.5s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <h1>PAC-XON</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="gameInfo">
        <div>
            <span>LIVES</span>
            <span id="lives">3</span>
        </div>
        <div>
            <span>SCORE</span>
            <span id="score">0</span>
        </div>
        <div>
            <span>PROGRESS</span>
            <span id="progress">0</span>%
        </div>
        <div>
            <span>LEVEL</span>
            <span id="level">1</span>
        </div>
    </div>
    <div id="controls">
        <p>Use <span class="key">↑</span> <span class="key">↓</span> <span class="key">←</span> <span class="key">→</span> or <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to move</p>
        <p>Fill 80% of the area to advance to the next level!</p>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen">
        <div class="victory-content">
            <div class="victory-title">LEVEL COMPLETE!</div>
            <div class="celebration-text">✨ Congratulations! You've conquered this level! ✨</div>
            
            <div class="victory-stats">
                <div class="victory-stat">
                    <div class="victory-stat-label">Level</div>
                    <div class="victory-stat-value" id="victoryLevel">1</div>
                </div>
                <div class="victory-stat">
                    <div class="victory-stat-label">Score</div>
                    <div class="victory-stat-value" id="victoryScore">0</div>
                </div>
                <div class="victory-stat">
                    <div class="victory-stat-label">Area Filled</div>
                    <div class="victory-stat-value" id="victoryProgress">80%</div>
                </div>
                <div class="victory-stat">
                    <div class="victory-stat-label">Bonus</div>
                    <div class="victory-stat-value" id="victoryBonus">1000</div>
                </div>
            </div>
            
            <button class="next-level-btn" onclick="game.proceedToNextLevel()">
                Continue to Level <span id="nextLevelNumber">2</span>
            </button>
        </div>
    </div>
    
    <script>
        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GRID_SIZE = 20;
        const GRID_WIDTH = CANVAS_WIDTH / GRID_SIZE;
        const GRID_HEIGHT = CANVAS_HEIGHT / GRID_SIZE;

        // Cell types
        const CELL_TYPES = {
            EMPTY: 0,
            FILLED: 1,
            WALL: 2,
            TRAIL: 3
        };

        // Directions
        const DIRECTIONS = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // Global game instance
        let game;

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Game state
                this.gameRunning = true;
                this.levelComplete = false;
                this.lives = 3;
                this.score = 0;
                this.level = 1;
                this.time = 0;
                
                // Initialize game field
                this.initializeGrid();
                
                // Player
                this.player = new Player(0, Math.floor(GRID_HEIGHT / 2));
                
                // Ghosts
                this.ghosts = [];
                this.initializeGhosts();
                
                // Fruits
                this.fruits = [];
                this.fruitSpawnTimer = 0;
                this.fruitSpawnInterval = 8000;
                
                // Input handling
                this.keys = {};
                this.setupInput();
                
                // Game loop
                this.lastTime = 0;
                this.gameLoop();
                
                // UI update
                this.updateUI();
            }
            
            initializeGrid() {
                this.grid = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (x === 0 || x === GRID_WIDTH - 1 || y === 0 || y === GRID_HEIGHT - 1) {
                            this.grid[x][y] = CELL_TYPES.FILLED;
                        } else {
                            this.grid[x][y] = CELL_TYPES.EMPTY;
                        }
                    }
                }
            }
            
            initializeGhosts() {
                this.ghosts = [];
                for (let i = 0; i < this.level + 1; i++) {
                    this.ghosts.push(new Ghost(
                        Math.floor(GRID_WIDTH / 2) + i * 3,
                        Math.floor(GRID_HEIGHT / 2) + i * 2,
                        'purple'
                    ));
                }
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            handleInput() {
                if (this.levelComplete) return; // Don't handle input during victory screen

                let direction = null;
                
                if (this.keys['ArrowUp'] || this.keys['KeyW']) {
                    direction = DIRECTIONS.UP;
                } else if (this.keys['ArrowDown'] || this.keys['KeyS']) {
                    direction = DIRECTIONS.DOWN;
                } else if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    direction = DIRECTIONS.LEFT;
                } else if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    direction = DIRECTIONS.RIGHT;
                }
                
                if (direction) {
                    this.player.setDirection(direction);
                }
            }
            
            update(deltaTime) {
                if (!this.gameRunning || this.levelComplete) return;
                
                this.time += deltaTime;
                this.handleInput();
                
                // Update player
                this.player.update(deltaTime, this.grid);
                
                // Update ghosts
                this.ghosts.forEach(ghost => {
                    ghost.update(deltaTime, this.grid);
                });
                
                // Update fruits
                this.updateFruits(deltaTime);
                
                // Check collisions
                this.checkCollisions();
                
                // Check if area capture is complete
                if (this.player.completedCapture) {
                    this.fillCapturedArea();
                    this.player.completedCapture = false;
                }
                
                // Check fruit collection
                this.checkFruitCollection();
                
                // Check win condition
                this.checkWinCondition();
                
                // Update UI
                this.updateUI();
            }
            
            checkCollisions() {
                this.ghosts.forEach(ghost => {
                    if (ghost.x === this.player.x && ghost.y === this.player.y) {
                        this.playerHit();
                        return;
                    }
                    
                    if (this.grid[ghost.x] && this.grid[ghost.x][ghost.y] === CELL_TYPES.TRAIL) {
                        this.playerHit();
                        return;
                    }
                });
            }
            
            playerHit() {
                this.lives--;
                this.clearTrail();
                this.player.resetToSafePosition();
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
            
            clearTrail() {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (this.grid[x][y] === CELL_TYPES.TRAIL) {
                            this.grid[x][y] = CELL_TYPES.EMPTY;
                        }
                    }
                }
            }
            
            fillCapturedArea() {
                // Convert trails to filled areas
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (this.grid[x][y] === CELL_TYPES.TRAIL) {
                            this.grid[x][y] = CELL_TYPES.FILLED;
                        }
                    }
                }
                
                // Find and fill enclosed areas
                const visited = Array(GRID_WIDTH).fill().map(() => Array(GRID_HEIGHT).fill(false));
                
                for (let x = 1; x < GRID_WIDTH - 1; x++) {
                    for (let y = 1; y < GRID_HEIGHT - 1; y++) {
                        if (this.grid[x][y] === CELL_TYPES.EMPTY && !visited[x][y]) {
                            const area = this.floodFill(x, y, visited);
                            
                            let hasGhost = false;
                            for (let ghost of this.ghosts) {
                                if (area.some(cell => cell.x === ghost.x && cell.y === ghost.y)) {
                                    hasGhost = true;
                                    break;
                                }
                            }
                            
                            if (!hasGhost && area.length > 0) {
                                area.forEach(cell => {
                                    this.grid[cell.x][cell.y] = CELL_TYPES.FILLED;
                                });
                                this.score += area.length * 10;
                            }
                        }
                    }
                }
            }
            
            floodFill(startX, startY, visited) {
                const stack = [{ x: startX, y: startY }];
                const area = [];
                
                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    
                    if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) {
                        continue;
                    }
                    
                    if (visited[x][y]) {
                        continue;
                    }
                    
                    if (!this.grid[x] || this.grid[x][y] !== CELL_TYPES.EMPTY) {
                        continue;
                    }
                    
                    visited[x][y] = true;
                    area.push({ x, y });
                    
                    stack.push({ x: x + 1, y });
                    stack.push({ x: x - 1, y });
                    stack.push({ x, y: y + 1 });
                    stack.push({ x, y: y - 1 });
                }
                
                return area;
            }
            
            checkFruitCollection() {
                if (!this.player.inSafeZone) return;
                
                const playerX = this.player.x;
                const playerY = this.player.y;
                
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    const fruit = this.fruits[i];
                    if (fruit.x === playerX && fruit.y === playerY) {
                        this.fruits.splice(i, 1);
                        this.player.applySpeedBoost();
                        this.score += 500;
                        break;
                    }
                }
            }
            
            updateFruits(deltaTime) {
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    this.fruits[i].update(deltaTime);
                    if (this.fruits[i].isExpired()) {
                        this.fruits.splice(i, 1);
                    }
                }
                
                this.fruitSpawnTimer += deltaTime;
                if (this.fruitSpawnTimer >= this.fruitSpawnInterval && this.fruits.length < 2) {
                    this.spawnFruit();
                    this.fruitSpawnTimer = 0;
                }
            }
            
            spawnFruit() {
                const validPositions = [];
                
                for (let x = 3; x < GRID_WIDTH - 3; x++) {
                    for (let y = 3; y < GRID_HEIGHT - 3; y++) {
                        if (this.grid[x][y] === CELL_TYPES.FILLED) {
                            const playerDistance = Math.abs(x - this.player.x) + Math.abs(y - this.player.y);
                            
                            if (playerDistance > 5) {
                                validPositions.push({ x, y });
                            }
                        }
                    }
                }
                
                if (validPositions.length > 0) {
                    const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
                    this.fruits.push(new Fruit(pos.x, pos.y, 'cherry'));
                }
            }
            
            checkWinCondition() {
                const filledCells = this.countFilledCells();
                const totalCells = (GRID_WIDTH - 2) * (GRID_HEIGHT - 2);
                const progress = Math.floor((filledCells / totalCells) * 100);
                
                if (progress >= 80) {
                    this.showVictoryScreen(progress);
                }
            }
            
            countFilledCells() {
                let count = 0;
                for (let x = 1; x < GRID_WIDTH - 1; x++) {
                    for (let y = 1; y < GRID_HEIGHT - 1; y++) {
                        if (this.grid[x][y] === CELL_TYPES.FILLED) {
                            count++;
                        }
                    }
                }
                return count;
            }
            
            nextLevel() {
                this.level++;
                this.score += 1000 * this.level;
                this.initializeGrid();
                this.player.resetToSafePosition();
                this.initializeGhosts();
            }
            
            gameOver() {
                this.gameRunning = false;
                alert(`Game Over! Final Score: ${this.score}`);
            }
            
            updateUI() {
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('score').textContent = this.score.toLocaleString();
                document.getElementById('level').textContent = this.level;
                
                const filledCells = this.countFilledCells();
                const totalCells = (GRID_WIDTH - 2) * (GRID_HEIGHT - 2);
                const progress = Math.floor((filledCells / totalCells) * 100);
                document.getElementById('progress').textContent = progress;
            }
            
            render() {
                const gradient = this.ctx.createRadialGradient(
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 0,
                    CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) / 2
                );
                gradient.addColorStop(0, '#0a0a0a');
                gradient.addColorStop(1, '#1a0a1a');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                this.drawGrid();
                
                this.fruits.forEach(fruit => {
                    fruit.render(this.ctx, this.time);
                });
                
                this.player.render(this.ctx, this.time);
                
                this.ghosts.forEach(ghost => {
                    ghost.render(this.ctx, this.time);
                });
                
                if (this.player.hasSpeedBoost()) {
                    this.drawSpeedBoostIndicator();
                }
            }
            
            drawGrid() {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        const cellType = this.grid[x][y];
                        
                        if (cellType !== CELL_TYPES.EMPTY) {
                            this.ctx.save();
                            
                            const cellX = x * GRID_SIZE;
                            const cellY = y * GRID_SIZE;
                            
                            switch (cellType) {
                                case CELL_TYPES.FILLED:
                                    const blueGradient = this.ctx.createLinearGradient(
                                        cellX, cellY, cellX + GRID_SIZE, cellY + GRID_SIZE
                                    );
                                    blueGradient.addColorStop(0, '#0066ff');
                                    blueGradient.addColorStop(0.5, '#0099ff');
                                    blueGradient.addColorStop(1, '#0044aa');
                                    this.ctx.fillStyle = blueGradient;
                                    this.ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                                    
                                    this.ctx.strokeStyle = '#00ccff';
                                    this.ctx.lineWidth = 1;
                                    this.ctx.strokeRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                                    break;
                                    
                                case CELL_TYPES.TRAIL:
                                    const pulse = Math.sin(this.time * 0.01) * 0.3 + 0.7;
                                    const yellowGradient = this.ctx.createRadialGradient(
                                        cellX + GRID_SIZE/2, cellY + GRID_SIZE/2, 0,
                                        cellX + GRID_SIZE/2, cellY + GRID_SIZE/2, GRID_SIZE/2
                                    );
                                    yellowGradient.addColorStop(0, `rgba(255, 255, 0, ${pulse})`);
                                    yellowGradient.addColorStop(1, `rgba(255, 200, 0, ${pulse * 0.5})`);
                                    this.ctx.fillStyle = yellowGradient;
                                    this.ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                                    
                                    this.ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.8})`;
                                    this.ctx.fillRect(cellX + GRID_SIZE/2 - 1, cellY + GRID_SIZE/2 - 1, 2, 2);
                                    break;
                            }
                            
                            this.ctx.restore();
                        }
                    }
                }
            }
            
            drawSpeedBoostIndicator() {
                const timeLeft = this.player.speedBoostTimer;
                const totalTime = this.player.speedBoostDuration;
                const progress = timeLeft / totalTime;
                
                const barWidth = 200;
                const barHeight = 8;
                const barX = (CANVAS_WIDTH - barWidth) / 2;
                const barY = 20;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                
                const gradient = this.ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(1, '#0088ff');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                
                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = '12px Orbitron';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('SPEED BOOST', CANVAS_WIDTH / 2, barY - 8);
            }
            
            gameLoop(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            showVictoryScreen(progress) {
                this.levelComplete = true;
                const levelBonus = 1000 * this.level;
                
                // Update victory screen data
                document.getElementById('victoryLevel').textContent = this.level;
                document.getElementById('victoryScore').textContent = this.score.toLocaleString();
                document.getElementById('victoryProgress').textContent = progress + '%';
                document.getElementById('victoryBonus').textContent = levelBonus.toLocaleString();
                document.getElementById('nextLevelNumber').textContent = this.level + 1;
                
                // Show victory screen
                document.getElementById('victoryScreen').style.display = 'flex';
            }
            
            proceedToNextLevel() {
                // Hide victory screen
                document.getElementById('victoryScreen').style.display = 'none';
                
                // Proceed to next level
                this.level++;
                this.score += 1000 * this.level;
                this.levelComplete = false;
                this.initializeGrid();
                this.player.resetToSafePosition();
                this.initializeGhosts();
                
                // Update UI
                this.updateUI();
                
                console.log("Proceeding to level", this.level);
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.direction = null;
                this.moveTimer = 0;
                this.baseSpeed = 150;
                this.moveSpeed = this.baseSpeed;
                this.inSafeZone = true;
                this.completedCapture = false;
                this.mouthAnimation = 0;
                this.speedBoostTimer = 0;
                this.speedBoostDuration = 5000;
            }
            
            setDirection(direction) {
                this.direction = direction;
            }
            
            update(deltaTime, grid) {
                if (!this.direction) return;
                
                this.mouthAnimation += deltaTime * 0.01;
                
                if (this.speedBoostTimer > 0) {
                    this.speedBoostTimer -= deltaTime;
                    this.moveSpeed = this.baseSpeed * 0.6;
                } else {
                    this.moveSpeed = this.baseSpeed;
                }
                
                this.moveTimer += deltaTime;
                
                if (this.moveTimer >= this.moveSpeed) {
                    this.move(grid);
                    this.moveTimer = 0;
                }
            }
            
            applySpeedBoost() {
                this.speedBoostTimer = this.speedBoostDuration;
            }
            
            hasSpeedBoost() {
                return this.speedBoostTimer > 0;
            }
            
            move(grid) {
                const newX = this.x + this.direction.x;
                const newY = this.y + this.direction.y;
                
                if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
                    return;
                }
                
                if (grid[newX][newY] === CELL_TYPES.TRAIL) {
                    return;
                }
                
                this.x = newX;
                this.y = newY;
                
                const newCellType = grid[this.x][this.y];
                
                if (this.inSafeZone) {
                    if (newCellType === CELL_TYPES.FILLED) {
                        this.inSafeZone = true;
                    } else if (newCellType === CELL_TYPES.EMPTY) {
                        this.inSafeZone = false;
                        grid[this.x][this.y] = CELL_TYPES.TRAIL;
                    }
                } else {
                    if (newCellType === CELL_TYPES.FILLED) {
                        this.completeCapture(grid);
                    } else if (newCellType === CELL_TYPES.EMPTY) {
                        grid[this.x][this.y] = CELL_TYPES.TRAIL;
                    }
                }
            }
            
            completeCapture(grid) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (grid[x][y] === CELL_TYPES.TRAIL) {
                            grid[x][y] = CELL_TYPES.FILLED;
                        }
                    }
                }
                
                this.inSafeZone = true;
                this.completedCapture = true;
            }
            
            resetToSafePosition() {
                this.x = 0;
                this.y = Math.floor(GRID_HEIGHT / 2);
                this.inSafeZone = true;
                this.direction = null;
                this.speedBoostTimer = 0;
            }
            
            render(ctx, time) {
                const centerX = this.x * GRID_SIZE + GRID_SIZE / 2;
                const centerY = this.y * GRID_SIZE + GRID_SIZE / 2;
                const radius = GRID_SIZE / 3;
                
                const pulse = Math.sin(time * 0.008) * 0.3 + 0.7;
                const glowIntensity = this.hasSpeedBoost() ? pulse * 1.5 : pulse;
                const glowColor = this.hasSpeedBoost() ? '#00ffff' : '#ffff00';
                
                ctx.save();
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 15 * glowIntensity;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${0.3 * glowIntensity})`;
                ctx.fill();
                ctx.restore();
                
                let mouthAngle = 0;
                if (this.direction) {
                    if (this.direction.x === 1) mouthAngle = 0;
                    else if (this.direction.x === -1) mouthAngle = Math.PI;
                    else if (this.direction.y === -1) mouthAngle = -Math.PI / 2;
                    else if (this.direction.y === 1) mouthAngle = Math.PI / 2;
                }
                
                const mouthOpenness = Math.abs(Math.sin(this.mouthAnimation)) * 0.8 + 0.2;
                const mouthSize = mouthOpenness * Math.PI / 3;
                
                const gradient = ctx.createRadialGradient(
                    centerX - radius/3, centerY - radius/3, 0,
                    centerX, centerY, radius
                );
                
                if (this.hasSpeedBoost()) {
                    gradient.addColorStop(0, '#ffffcc');
                    gradient.addColorStop(0.7, '#ffff00');
                    gradient.addColorStop(1, '#00ffff');
                } else {
                    gradient.addColorStop(0, '#ffff99');
                    gradient.addColorStop(0.7, '#ffff00');
                    gradient.addColorStop(1, '#cccc00');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                
                if (mouthOpenness > 0.3) {
                    ctx.arc(
                        centerX, centerY, radius,
                        mouthAngle - mouthSize/2, 
                        mouthAngle + mouthSize/2,
                        true
                    );
                    ctx.lineTo(centerX, centerY);
                } else {
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                }
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(centerX - radius/3, centerY - radius/3, radius/3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(centerX - radius/4, centerY - radius/4, radius/8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX - radius/4 + 1, centerY - radius/4 - 1, radius/16, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Ghost {
            constructor(x, y, type = 'purple') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.direction = this.getRandomDirection();
                this.moveTimer = 0;
                this.moveSpeed = 300;
                this.color = this.getColor();
            }
            
            getColor() {
                const colors = {
                    'purple': '#ff00ff',
                    'orange': '#ff8800',
                    'blue': '#0088ff',
                    'red': '#ff0000'
                };
                return colors[this.type] || '#ff00ff';
            }
            
            getRandomDirection() {
                const directions = Object.values(DIRECTIONS);
                return directions[Math.floor(Math.random() * directions.length)];
            }
            
            update(deltaTime, grid) {
                this.moveTimer += deltaTime;
                
                if (this.moveTimer >= this.moveSpeed) {
                    this.move(grid);
                    this.moveTimer = 0;
                }
            }
            
            move(grid) {
                const newX = this.x + this.direction.x;
                const newY = this.y + this.direction.y;
                
                if (newX < 1 || newX >= GRID_WIDTH - 1 || 
                    newY < 1 || newY >= GRID_HEIGHT - 1 ||
                    grid[newX][newY] === CELL_TYPES.FILLED ||
                    grid[newX][newY] === CELL_TYPES.WALL) {
                    
                    this.direction = this.getRandomDirection();
                    return;
                }
                
                this.x = newX;
                this.y = newY;
            }
            
            render(ctx, time) {
                const centerX = this.x * GRID_SIZE + GRID_SIZE / 2;
                const centerY = this.y * GRID_SIZE + GRID_SIZE / 2;
                const radius = GRID_SIZE / 3;
                
                const float = Math.sin(time * 0.005 + this.x + this.y) * 2;
                const floatY = centerY + float;
                
                ctx.save();
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                const gradient = ctx.createRadialGradient(
                    centerX, floatY - radius/2, 0,
                    centerX, floatY, radius
                );
                gradient.addColorStop(0, this.color + 'dd');
                gradient.addColorStop(1, this.color + '66');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, floatY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(centerX - radius/3, floatY - radius/4, radius/6, 0, Math.PI * 2);
                ctx.arc(centerX + radius/3, floatY - radius/4, radius/6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX - radius/3 + 1, floatY - radius/4 - 1, radius/12, 0, Math.PI * 2);
                ctx.arc(centerX + radius/3 + 1, floatY - radius/4 - 1, radius/12, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Fruit {
            constructor(x, y, type = 'cherry') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.lifeTimer = 0;
                this.maxLife = 15000;
                this.pulseAnimation = 0;
            }
            
            update(deltaTime) {
                this.lifeTimer += deltaTime;
                this.pulseAnimation += deltaTime * 0.005;
            }
            
            isExpired() {
                return this.lifeTimer >= this.maxLife;
            }
            
            render(ctx, time) {
                const centerX = this.x * GRID_SIZE + GRID_SIZE / 2;
                const centerY = this.y * GRID_SIZE + GRID_SIZE / 2;
                const radius = GRID_SIZE / 4;
                
                const pulse = Math.sin(this.pulseAnimation) * 0.2 + 0.8;
                const currentRadius = radius * pulse;
                
                const timeLeft = this.maxLife - this.lifeTimer;
                let alpha = 1;
                if (timeLeft < 5000) {
                    alpha = Math.sin(time * 0.02) * 0.5 + 0.5;
                }
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 8 * pulse;
                
                const gradient = ctx.createRadialGradient(
                    centerX - currentRadius/3, centerY - currentRadius/3, 0,
                    centerX, centerY, currentRadius
                );
                gradient.addColorStop(0, '#ff9999');
                gradient.addColorStop(0.7, '#ff3333');
                gradient.addColorStop(1, '#cc0000');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(centerX - currentRadius/3, centerY - currentRadius/3, currentRadius/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#00aa00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - currentRadius);
                ctx.lineTo(centerX - 2, centerY - currentRadius - 4);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            console.log("Starting Pac-Xon game...");
            game = new Game();
        });
    </script>
</body>
</html>